name: Release (macOS)

on:
  release:
    types: [published]

permissions:
  contents: write

jobs:
  build-sign-notarize-release:
    name: Build ‚Üí Sign ‚Üí Notarize ‚Üí Release
    runs-on: macos-15
    environment: release
    env:
      APP_NAME: Annotate
      SCHEME: Annotate
      CONFIG: Release
      ARCHIVE_PATH: build/Annotate.xcarchive
      EXPORT_DIR: build/export
      EXPORT_PLIST: packaging/ExportOptions.plist

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode 16.2
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.2'
          
      - name: Verify Xcode version
        run: xcodebuild -version


      - name: Inject TEAM_ID into ExportOptions
        run: |
          sed "s/__TEAM_ID__/${{ secrets.TEAM_ID }}/" "$EXPORT_PLIST" > "$EXPORT_PLIST.out"
          mv "$EXPORT_PLIST.out" "$EXPORT_PLIST"

      - name: Import Developer ID certificate
        uses: apple-actions/import-codesign-certs@v5
        with:
          p12-file-base64: ${{ secrets.MACOS_CERT_BASE64 }}
          p12-password: ${{ secrets.MACOS_CERT_PASSWORD }}


      - name: Install xcpretty
        run: gem install xcpretty --no-document

      - name: Xcode archive (arm64, verbose, unsigned)
        run: |
          set -euxo pipefail
          mkdir -p build
          ENTRY="-project Annotate.xcodeproj"
          xcodebuild \
            $ENTRY \
            -scheme "$SCHEME" \
            -configuration "$CONFIG" \
            -archivePath "$ARCHIVE_PATH" \
            -destination "generic/platform=macOS" \
            ARCHS=arm64 \
            CODE_SIGNING_ALLOWED=NO \
            MARKETING_VERSION=${{ github.event.release.tag_name }} \
            clean archive | xcpretty && exit ${PIPESTATUS[0]}

      - name: Export signed app (Developer ID)
        run: |
          mkdir -p "$EXPORT_DIR"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_DIR" \
            -exportOptionsPlist "$EXPORT_PLIST" | xcpretty && exit ${PIPESTATUS[0]}

      - name: Re-sign with hardened runtime
        run: |
          codesign --force --sign "Developer ID Application" \
            -o runtime --timestamp \
            --entitlements "$APP_NAME/$APP_NAME.entitlements" \
            "$EXPORT_DIR/$APP_NAME.app"

      - name: Package DMG
        run: |
          chmod +x packaging/make_dmg.sh
          DMG_PATH=$(./packaging/make_dmg.sh)
          echo "DMG_PATH=$DMG_PATH" >> $GITHUB_ENV

      - name: Notarize (notarytool --wait)
        run: |
          xcrun notarytool submit "$DMG_PATH" \
            --apple-id "${{ secrets.NOTARIZE_APPLE_ID }}" \
            --password "${{ secrets.NOTARIZE_PASSWORD }}" \
            --team-id "${{ secrets.TEAM_ID }}" \
            --wait

      - name: Validate & staple for distribution
        run: |
          echo "Verifying app signature and entitlements..."
          codesign --verify --deep --strict --verbose=2 "$EXPORT_DIR/$APP_NAME.app"
          spctl -a -vvv --type exec "$EXPORT_DIR/$APP_NAME.app"

          echo "Stapling notarization ticket to DMG..."
          xcrun stapler staple "$DMG_PATH"
          xcrun stapler validate "$DMG_PATH"

      - name: Install Sparkle tools
        run: |
          curl -L https://github.com/sparkle-project/Sparkle/releases/download/2.8.0/Sparkle-2.8.0.tar.xz | tar -xJ

      - name: Generate appcast signature
        id: appcast
        run: |
          # Get file size
          FILE_SIZE=$(stat -f%z "$DMG_PATH")
          echo "file_size=$FILE_SIZE" >> "$GITHUB_OUTPUT"
          
          # Generate EdDSA signature
          echo "${{ secrets.SPARKLE_PRIVATE_KEY }}" > private_key.pem
          SIGNATURE=$(./Sparkle-2.8.0/bin/sign_update "$DMG_PATH" private_key.pem)
          echo "signature=$SIGNATURE" >> "$GITHUB_OUTPUT"
          rm private_key.pem
          
          # Get bundle version from built app
          BUNDLE_VERSION=$(defaults read "$EXPORT_DIR/$APP_NAME.app/Contents/Info.plist" CFBundleVersion)
          echo "bundle_version=$BUNDLE_VERSION" >> "$GITHUB_OUTPUT"

      - name: Prepare release body
        id: release_notes
        run: |
          # Use the actual release description from the GitHub event
          RELEASE_BODY="${{ github.event.release.body }}"
          
          # Extract semantic version (remove 'v' prefix if present)
          TAG_NAME="${{ github.event.release.tag_name }}"
          SEMVER="${TAG_NAME#v}"
          echo "semantic_version=$SEMVER" >> "$GITHUB_OUTPUT"
          
          # Check if this is a prerelease
          IS_PRERELEASE="${{ github.event.release.prerelease }}"
          echo "is_prerelease=$IS_PRERELEASE" >> "$GITHUB_OUTPUT"
          
          # Fallback if release body is empty
          if [ -z "$RELEASE_BODY" ]; then
            RELEASE_BODY="## üöÄ Annotate ${{ github.event.release.tag_name }}

Enhanced drawing tools, performance improvements, and bug fixes."
          fi
          
          # Store in output for appcast
          echo "release_body<<EOF" >> "$GITHUB_OUTPUT"
          echo "$RELEASE_BODY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Upload DMG to existing release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.release.tag_name }}
          files: |
            ${{ env.DMG_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name: Update appcast.xml  
        if: ${{ steps.release_notes.outputs.is_prerelease == 'false' }}
        run: |
          cat > new_entry.xml << EOF
          <item>
              <title>Version ${{ github.event.release.tag_name }}</title>
              <link>https://github.com/epilande/Annotate/releases/tag/${{ github.event.release.tag_name }}</link>
              <description><![CDATA[
${{ steps.release_notes.outputs.release_body }}
              ]]></description>
              <pubDate>$(date -R)</pubDate>
              <enclosure url="https://github.com/epilande/Annotate/releases/download/${{ github.event.release.tag_name }}/$(basename "$DMG_PATH")"
                         sparkle:version="${{ steps.appcast.outputs.bundle_version }}"
                         sparkle:shortVersionString="${{ steps.release_notes.outputs.semantic_version }}"
                         sparkle:edSignature="${{ steps.appcast.outputs.signature }}"
                         length="${{ steps.appcast.outputs.file_size }}"
                         type="application/octet-stream" />
          </item>
          EOF
          
          echo "Generated appcast entry:"
          cat new_entry.xml
          
          # Insert new entry into appcast.xml after the channel description
          sed -i.bak '/^        <description>.*<\/description>$/r new_entry.xml' appcast.xml
          rm new_entry.xml appcast.xml.bak

      - name: Commit updated appcast
        if: ${{ steps.release_notes.outputs.is_prerelease == 'false' }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add appcast.xml
          git commit -m "Update appcast.xml for ${{ github.event.release.tag_name }}"
          git push origin HEAD:auto-update

      - name: Skip appcast update (prerelease)
        if: ${{ steps.release_notes.outputs.is_prerelease == 'true' }}
        run: |
          echo "‚ö†Ô∏è  Skipping appcast update for prerelease ${{ github.event.release.tag_name }}"
          echo "   Users will not be notified of this beta/RC version via auto-updates"


